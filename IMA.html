<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <title>IMA Feladatok Gyűjteménye</title>
    <style>
        body { font-family: sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f4f4f4; }
        .code-container { background: #fff; border: 1px solid #ddd; border-left: 5px solid #2ecc71; padding: 15px; margin-bottom: 30px; border-radius: 5px; }
        pre { background: #272822; color: #f8f8f2; padding: 15px; overflow-x: auto; border-radius: 5px; }
        h2 { color: #333; border-bottom: 2px solid #2ecc71; padding-bottom: 5px; }
    </style>
</head>
<body>
    <h1>IMA Feladatok és Megoldások</h1>

    <div class="code-container">
        <h2>1. Akciós potenciálok</h2>
        <pre><code>
import matplotlib.pyplot as plt

time=[]
ap1=[]
ap2=[]
ap3=[]
ap4=[]


with open ('ap.csv', 'r', encoding='utf-8') as f:
    next(f)
    for line in f:
        line = line.strip()
        if not line:
            continue

        data = line.strip().split(",")

        if len(data) < 5:
            continue

        try:
            time.append(float(data[0]))
            ap1.append(float(data[1]))
            ap2.append(float(data[2]))
            ap3.append(float(data[3]))
            ap4.append(float(data[4]))
        except (IndexError, ValueError):# Ha egy sor hibás vagy hiányzik adat, nem áll le a kód
            continue
    print(ap1)
    print(ap2)
    print(ap3)
    print(ap4)

plt.plot(time, ap1, label="AP1", color="green")
plt.plot(time, ap2, label="AP2", color="red")
plt.plot(time, ap3, label="AP3", color="blue")
plt.plot(time, ap4, label="AP4", color="yellow")
plt.xlabel("idő (ms)")
plt.ylabel("akciós potenciál(mV)")
plt.savefig('ábra1.png')
plt.show()

pozitiv_start_index=None
pozitiv_stop_index=None
pozitiv_tartomany=[]

for i in range(len(ap1)):
    if pozitiv_start_index==None and ap1[i]>=0:
        pozitiv_start_index=i
    if pozitiv_start_index!=None and ap1[i]<=0:
        pozitiv_stop_index=i-1

for pozitivak in ap1[pozitiv_start_index:(pozitiv_stop_index+1)]:
    pozitiv_tartomany.append(pozitivak)
print(pozitiv_tartomany)

#Legnagyobb és legkisebb AP
min_AP=min(ap1)
max_AP=max(ap1)
print(f"Legkisebb akciós potenciál {min_AP}")
print(f"legnagyobb akciós potenciál {max_AP}")

#pozitív százalék
pozitiv_db = 0

for ertek in ap1:
    if ertek > 0:
        pozitiv_db += 1

pozitiv_szazalek = pozitiv_db / len(ap1) * 100
print(f"Pozitív tartomány aránya: {pozitiv_szazalek:.2f} %")

#Mintavételi frekvencia
dt = time[1] - time[0]
mintaveteli_frekvencia = 1 / dt
print("Mintavételi frekvencia:", mintaveteli_frekvencia, "Hz")

#maximális sebesség
sebessegek = []

for i in range(len(ap1) - 1):
    seb = abs((ap1[i+1] - ap1[i]) / (time[i+1] - time[i]))
    sebessegek.append(seb)

max_sebesseg = max(sebessegek)
print("Legnagyobb sebesség:", max_sebesseg, "mV/ms")

#amplitúdó
amplitudo_ap1 = max(ap1) - min(ap1)
print("AP1 amplitúdó:", amplitudo_ap1)

#AP1 és AP2 időeltolódása
max_index_ap1 = ap1.index(max(ap1))
max_index_ap2 = ap2.index(max(ap2))

idoeltolodas = time[max_index_ap2] - time[max_index_ap1]

print("AP2 időeltolódása az első folyamathoz képest:", idoeltolodas, "ms")
</code></pre>
    </div>

    <div class="code-container">
        <h2>2. Első és Másodfokú Polinom Illesztése</h2>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# adatok beolvasása listákba
X = []
Y = []

with open("Illesztes.csv", "r", encoding="utf-8") as f:
    next(f)
    for sor in f:
        sor=sor.strip()
        if not sor:
            continue

        adat=sor.strip().split(",")

        if len(adat) < 2:
            continue

        X.append(float(adat[0]))
        Y.append(float(adat[1]))

print(X)
print(Y)

# eredeti adatok ábrázolása
plt.scatter(X, Y, label="Mért adatok")

# Elsőfokú illesztés
coeff1 = np.polyfit(X, Y, 1)
Y_fit1 = np.polyval(coeff1, X)
# Másodfokú illesztés
coeff2 = np.polyfit(X, Y, 2)
Y_fit2 = np.polyval(coeff2, X)

# R2 számítása
y_atlag = sum(Y) / len(Y)

maradek_negyzetosszeg1 = 0
teljes_negyzetosszeg1 = 0
maradek_negyzetosszeg2 = 0
teljes_negyzetosszeg2 = 0

for i in range(len(Y)):
    maradek_negyzetosszeg1 += (Y[i] - Y_fit1[i]) ** 2
    teljes_negyzetosszeg1 += (Y[i] - y_atlag) ** 2

r2_1 = 1 - maradek_negyzetosszeg1 / teljes_negyzetosszeg1

for i in range(len(Y)):
    maradek_negyzetosszeg2 += (Y[i] - Y_fit2[i]) ** 2
    teljes_negyzetosszeg2 += (Y[i] - y_atlag) ** 2

r2_2 = 1 - maradek_negyzetosszeg2 / teljes_negyzetosszeg2

# illesztett görbe
plt.plot(X, Y_fit1, label=f"Illesztett egyenes (R²={r2_1:.2f})")
plt.plot(X, Y_fit2, label=f"Illesztett másodfokú (R²={r2_2:.2f})")

plt.xlabel("X")
plt.ylabel("Y")
plt.title("Adatok és lineáris illesztés")
plt.legend()
plt.grid(True)
plt.show()

print("R²_1 érték:", r2_1)
print("R²_2 érték:", r2_2)
</code></pre>
    </div>
    <div class="code-container">
        <h2>3. Exponenciális illesztés</h2>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# adatok beolvasása
X = []
Y = []

with open("Exponencialis.csv", "r", encoding="utf-8") as f:
    next(f)
    for line in f:
        if not line.strip():
            continue
        x, y = line.strip().split(",")
        X.append(float(x))
        Y.append(float(y))

X = np.array(X)
Y = np.array(Y)

# exponenciális illesztés: y = a * e^(b*x)
lnY = np.log(Y)
b, ln_a = np.polyfit(X, lnY, 1)
a = np.exp(ln_a)

Y_fit = a * np.exp(b * X)

# R² számítása
ss_res = np.sum((Y - Y_fit) ** 2)
ss_tot = np.sum((Y - np.mean(Y)) ** 2)
r2 = 1 - ss_res / ss_tot

# ábrázolás
plt.scatter(X, Y, label="Mért adatok")
plt.plot(X, Y_fit, color="red",
         label=f"Exponenciális illesztés (R²={r2:.3f})")
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Exponenciális illesztés")
plt.legend()
plt.grid(True)
plt.show()

# paraméterek kiírása
print(f"Illesztett függvény: y = {a:.2f} * e^({b:.2f}x)")
print(f"R² = {r2:.3f}")
</code></pre>
    </div>

    <div class="code-container">
        <h2>4. Szinusz illesztés</h2>
        <pre><code>
import numpy as np
import matplotlib.pyplot as plt

# adatok beolvasása
X = []
Y = []

with open("Exponencialis.csv", "r", encoding="utf-8") as f:
    next(f)
    for line in f:
        if not line.strip():
            continue
        x, y = line.strip().split(",")
        X.append(float(x))
        Y.append(float(y))

X = np.array(X)
Y = np.array(Y)

# exponenciális illesztés: y = a * e^(b*x)
lnY = np.log(Y)
b, ln_a = np.polyfit(X, lnY, 1)
a = np.exp(ln_a)

Y_fit = a * np.exp(b * X)

# R² számítása
ss_res = np.sum((Y - Y_fit) ** 2)
ss_tot = np.sum((Y - np.mean(Y)) ** 2)
r2 = 1 - ss_res / ss_tot

# ábrázolás
plt.scatter(X, Y, label="Mért adatok")
plt.plot(X, Y_fit, color="red",
         label=f"Exponenciális illesztés (R²={r2:.3f})")
plt.xlabel("X")
plt.ylabel("Y")
plt.title("Exponenciális illesztés")
plt.legend()
plt.grid(True)
plt.show()

# paraméterek kiírása
print(f"Illesztett függvény: y = {a:.2f} * e^({b:.2f}x)")
print(f"R² = {r2:.3f}")
</code></pre>
    </div>
 
    <div class="code-container">
        <h2>5. Átlagoló és Medián Szűrő</h2>
        <pre><code>
import matplotlib.pyplot as plt

# ===== Adatok beolvasása =====
X = []
Y = []

with open("Szurok.csv", "r", encoding="utf-8") as f:
    next(f)
    for sor in f:
        sor=sor.strip()
        if not sor:
            continue

        adat=sor.strip().split(",")

        if len(adat) < 2:
            continue

        X.append(float(adat[0]))
        Y.append(float(adat[1]))

# ===== Átlagoló szűrő =====
Y_atlag=[]
for i in range(len(Y)):
    if i==0:
        atlag=(Y[i]+Y[i+1])/2
        Y_atlag.append(atlag)
    if i==(len(Y)-1):
        atlag=(Y[len(Y)-1]+Y[len(Y)-2])/2
        Y_atlag.append(atlag)
    if i!=0 and i!=(len(Y)-1):
        atlag=((Y[i-1])+Y[i]+Y[i+1])/3
        Y_atlag.append(atlag)

# ===== Medián szűrő =====
Y_median = []
n = len(Y)

for i in range(n):
    if i == 0:
        # Első elem: az első kettőből a medián (ami megegyezik az átlagukkal)
        ablak = sorted([Y[i], Y[i+1]])
        ertek = (ablak[0] + ablak[1]) / 2
        Y_median.append(ertek)
        
    elif i == n - 1:
        # Utolsó elem: az utolsó kettőből a medián (szintén az átlaguk)
        ablak = sorted([Y[i-1], Y[i]])
        ertek = (ablak[0] + ablak[1]) / 2
        Y_median.append(ertek)
        
    else:
        # Középső elemek: a három szomszéd közül a középső
        ablak = sorted([Y[i-1], Y[i], Y[i+1]])
        # A sorba rendezett listában az 1-es indexű a középső elem
        ertek = ablak[1]
        Y_median.append(ertek)


# ===== Ábrázolás =====
plt.plot(X, Y, label="Eredeti jel")
plt.plot(X, Y_atlag, label="Átlagoló szűrő")
plt.plot(X, Y_median, label="Medián szűrő")

plt.xlabel("X")
plt.ylabel("Y")
plt.title("Eredeti és szűrt jelek")
plt.legend()
plt.grid(True)
plt.show()
</code></pre>
    </div>
    
    <div class="code-container">
        <h2>6. ADC kód kiszámítása</h2>
        <p>A 12-bites A/D konverter referenciafeszültsége 1.5 V, az adat balra igazított.
Az A/D konverter bemenetére egy TMP36 hőmérsékletérzékelő kimenetét kötjük. A szenzor kimenetén 
            25ºC esetén 750 mV feszültség van, ennek változása lineáris, a meredekség 10mV/ºC. Az adcData értéke 
            29360, mekkora a hőmérséklet <0.1ºC pontossággal [ºC]?</p>
        <div class="image-gallery">
    <div class="image-item">
        <img src="ADC1.png" alt="ADC1">
         <img src="ADC2.png" alt="ADC2">
    </div>
</div>
    </div>

<div class="code-container">
        <h2>7. ADC Bemeneti és Kimeneti feszültség</h2>
        <p>Egy Vin feszültségjel feszültségosztón keresztül jut a 12-bites A/D konverter bemenetére. R1 és R2 értéke 6800 Ohm. Az A/D konverter 
            referenciafeszültsége 2.7 V, az adat jobbra igazított. Az adcData értéke 3125. Mekkora a Vin feszültségjel <0.1% pontossággal [V]</p>
        <div class="image-gallery">
    <div class="image-item">
        <img src="ADC3.png" alt="ADC3">
    </div>
</div>
    </div>

    
</body>
</html>
