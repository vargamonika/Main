<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Range</title>
    <style>
        :root {
            --primary-color: #2c3e50; /* Sötétkék/szürke */
            --secondary-color: #3498db; /* Élénk kék */
            --background-color: #ecf0f1; /* Világosszürke */
            --text-color: #2c3e50;
            --code-bg-color: #bdc3c7; /* Középszürke kód háttér */
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            font-style: italic;
            color: #7f8c8d;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .section p {
            margin-bottom: 10px;
        }
        .image-container {
            text-align: center;
            margin: 20px 0;
        }
        .image-container img {
            max-width: 40%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .code-container {
            background-color: var(--code-bg-color);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li::before {
            content: "• ";
            color: var(--secondary-color);
        }
        strong {
            color: var(--primary-color);
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Planets And Kingdoms</h1>
        <p>Példa input: 10 20 15 17 35 25 40 12 19 13 12</p>
    </header>

    <div class="image-container">
        <img src="P&K.png" alt="Kapcsolt Komponensek és Kondenzáció">
    </div>

    <div class="section">
       <p>A feladat lényege, hogy egy irányított gráfot kell felosztani olyan komponensekre, ahol a komponensen belüli bármely két pont (bolygó) között van oda-vissza út.
Ez a klasszikus Csúcserősen Összefüggő Komponensek (Strongly Connected Components, SCC) megtalálásának feladata az informatikában. </p>
    </div>

    <div class="section">
        <h2>1. A Feladat Részletezése</h2>

<p>1.	Modell: A bolygók (N darab) a csúcsok, a teleportok (M darab) az irányított élek. Ez egy irányított gráfot alkot.</p>
<p>2.	Királyság (SCC) Definíciója: Két bolygó, A és B ugyanahhoz a királysághoz tartozik, ha:</p>
        <ul>
<li>Van út A-ból B-be.</li>
<li>ÉS van út B-ből A-ba.</li>
<li>Ez pontosan megegyezik az SCC matematikai definíciójával.</li>
        </ul>
<p>3.	Cél:</p>
        <ul>
<li>Megtalálni az összes ilyen királyságot (SCC-t).</li>
<li>Kiszámolni a királyságok számát (K).</li>
<li>Minden bolygóhoz hozzárendelni a királyság sorszámát (1 és K között).</li>
        </ul>
    </div>

    <div class="section">
        <h2>2. A Megoldás: Kosaraju vagy Tarjan Algoritmus</h2>

<p>A feladat megoldására a leggyakoribb és leghatékonyabb algoritmus a már említett Kosaraju algoritmusa, amelyet a korábban bemutatott Java kód is implementál:</p>
<ul>
<li>1.	Első DFS (Befejezési Idő): Bejárjuk az eredeti gráfot, és minden bolygóra feljegyezzük a befejezési időt (mikor végez az adott ág rekurzív bejárása).</li>
<li>2.	Fordított Gráf: Létrehozzuk a gráf transzponáltját (az összes él irányát megfordítjuk).</li>
<li>3.	Második DFS (SCC Keresés): Elindítjuk a DFS-t a fordított gráfon, de nem tetszőleges sorrendben, hanem a bolygók első DFS-ben kapott befejezési idejének csökkenő
    sorrendje szerint. Minden egyes új DFS-indítás egy új, különálló királyságot (SCC-t) talál.</li>
</ul>
    <p>Az algoritmussal megtalálható, hogy a 3-as bolygó elérhető a 4-esből, és a 4-es is elérhető a 3-asból, de egyik sem érhető el az 1-esből, ezért:</p>
        <ul></ul>
<li>{1,2,3} az 1. királyság.</li>
<li>{4,5} a 2. királyság.</li>
        </ul>
<p>A kimenet tehát: 2 királyság, és a bolygók azonosítói: 1 1 1 2 2.</p>

    <div class="section">
        <h2>Java kód</h2>
        <div class="code-container">
            <pre>
import java.util.*;
import java.io.*;

public class KingdomCses {
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;
 
        public FastReader() {
            br = new BufferedReader(new InputStreamReader(System.in));
        }
 
        String next() {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }
 
        long nextLong() {
            return Long.parseLong(next());
        }
 
        int nextInt() {
            return Integer.parseInt(next());
        }
    }
 
    static long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }
 
    static void dfs(int node, List<List<Long>> adj, long[] finish, long[] timer, int[] vis) {
        vis[node] = 1;
        for (long i : adj.get(node)) {
            if (vis[(int) i] == 0) {
                dfs((int) i, adj, finish, timer, vis);
            }
        }
        finish[node] = timer[0]++;
    }
 
    static void dfs2(int node, int[] vis, List<List<Long>> adj, long king, long[] kingdom) {
        vis[node] = 1;
        kingdom[node] = king;
        for (long i : adj.get(node)) {
            if (vis[(int) i] == 0) {
                dfs2((int) i, vis, adj, king, kingdom);
            }
        }
    }
 
    public static void main(String[] args) {
        FastReader sc = new FastReader();
        int n = sc.nextInt();
        int m = sc.nextInt();
 
        List<List<Long>> adj = new ArrayList<>(n + 1);
        List<List<Long>> adjt = new ArrayList<>(n + 1);
        for (int i = 0; i <= n; i++) {
            adj.add(new ArrayList<>());
            adjt.add(new ArrayList<>());
        }
 
        for (int i = 0; i < m; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            adj.get(x).add((long) y);
            adjt.get(y).add((long) x);
        }
 
        long[] finish = new long[n + 1];
        Arrays.fill(finish, -1);
        int[] vis = new int[n + 1];
        long[] timer = new long[1];
 
        for (int i = 1; i <= n; i++) {
            if (vis[i] == 0) {
                dfs(i, adj, finish, timer, vis);
            }
        }
 
        Integer[] ord = new Integer[n];
        for (int i = 0; i < n; i++) {
            ord[i] = i + 1;
        }
 
        Arrays.sort(ord, (a, b) -> Long.compare(finish[b], finish[a]));
 
        Arrays.fill(vis, 0);
        long c = 0;
        long[] kingdom = new long[n + 1];
 
        for (int i = 0; i < n; i++) {
            if (vis[ord[i]] == 0) {
                c++;
                dfs2(ord[i], vis, adjt, c, kingdom);
            }
        }
 
        System.out.println(c);
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            sb.append(kingdom[i]).append(" ");
        }
        System.out.println(sb.toString().trim());
    }


A kód részletes magyarázata
        
Ez a Java kód egy klasszikus gráfalgoritmust valósít meg, a Kosaraju algoritmust vagy a Tarjan algoritmust a Csúcserősen Összefüggő Komponensek (Strongly Connected Components, SCC) megtalálására irányított gráfokban.

            1. Importok és Osztálydefiníciók
            
<b>import java.util.*;</b>	Importálja a Java segédprogramok gyűjteményét (pl. List, ArrayList, Arrays).
<b>import java.io.*;</b>	Importálja a bemeneti/kimeneti műveletekhez szükséges osztályokat (pl. BufferedReader, IOException).

            2. FastReader Segédosztály (Gyors Bemenetkezelés)

<b>public class KingdomCses {</b>	A fő osztály definiálása KingdomCses néven.
Ez az osztály a standard bemenet (konzol) gyorsabb beolvasására szolgál nagy adathalmazok esetén.
<b>static class FastReader {</b>	Egy statikus belső osztály a gyors beolvasáshoz.
<b>BufferedReader br;	BufferedReader</b>: Gyors, pufferezett olvasás a bemenetről.
<b>StringTokenizer st;	StringTokenizer</b>: Sorok szavakra (tokenekre) bontására szolgál.
<b>public FastReader() {</b>	Konstruktor.
<b>br = new BufferedReader(new InputStreamReader(System.in));</b>	Létrehozza a BufferedReader objektumot, amely a standard bemenetről olvas.
<b>String next() {</b>	A következő token (szó) beolvasására szolgáló metódus.
<b>while (st == null</b>	
<b>try { st = new StringTokenizer(br.readLine()); }</b>	Megpróbál beolvasni egy sort és tokenekre bontani.
<b>catch (IOException e) { e.printStackTrace(); }</b>	Kezeli a beolvasási hibát.
<b>return st.nextToken();</b>	Visszaadja a következő tokent.
<b>long nextLong() { return Long.parseLong(next()); }</b>	Beolvas egy long típusú számot.
<b>int nextInt() { return Integer.parseInt(next()); }</b>	Beolvas egy int típusú számot.
            
            3. Segédfüggvények
            
<b>static long gcd(long a, long b) {</b>	Euklideszi algoritmus a legnagyobb közös osztó (GCD) rekurzív kiszámítására. (Bár a fő feladathoz nem használt.)
<b>return b == 0 ? a : gcd(b, a % b);</b>	Rekurzív hívás.
<b>static void dfs(int node, List<List<Long>> adj, long[] finish, long[] timer, int[] vis) {</b>	Első Mélységi Keresés (DFS1): A bejárási befejezési idők kiszámítása.
<b>vis[node] = 1;</b>	Megjelöli a csúcsot látogatottként.
<b>for (long i : adj.get(node)) {</b>	Végigmegy a csúcs szomszédjain (kimenő éleken).
<b>if (vis[(int) i] == 0) {</b>	Ha a szomszéd még nem látogatott.
<b>dfs((int) i, adj, finish, timer, vis);</b>	Rekurzívan hívja a DFS-t a szomszédra.
<b>finish[node] = timer[0]++;</b>	Beállítja a csúcs befejezési idejét (finish[node]), és növeli az időzítőt (timer[0]).
<b>static void dfs2(int node, int[] vis, List<List<Long>> adj, long king, long[] kingdom) {</b>	Második Mélységi Keresés (DFS2): A Csúcserősen Összefüggő Komponensek (SCC) meghatározása.
<b>vis[node] = 1;</b>	Megjelöli a csúcsot látogatottként.
<b>kingdom[node] = king;</b>	Hozzárendeli az aktuális komponens (királyság, king) azonosítóját a csúcshoz.
<b>for (long i : adj.get(node)) {</b>	Végigmegy a csúcs szomszédjain a fordított gráfban (bejövő élek).
<b>if (vis[(int) i] == 0) {</b>	Ha a szomszéd még nem látogatott.
<b>dfs2((int) i, vis, adj, king, kingdom);</b>	Rekurzívan hívja a DFS2-t a szomszédra.

            4. A Fő Program (main metódus)
    
<b>FastReader sc = new FastReader();</b>	Létrehozza a gyors beolvasó objektumot.
<b>int n = sc.nextInt();</b>	Beolvassa a csúcsok számát (N).
<b>int m = sc.nextInt();</b>	Beolvassa az élek számát (M).
<b>List<List<Long>> adj = new ArrayList<>(n + 1); ... for (int i = 0; i <= n; i++) { adj.add(new ArrayList<>()); adjt.add(new ArrayList<>()); }</b>	Inicializálja a két szomszédsági listát: adj (eredeti gráf) és adjt (transzponált/fordított gráf) N+1 méretben.
<b>for (int i = 0; i < m; i++) { int x = sc.nextInt(); int y = sc.nextInt(); adj.get(x).add((long) y); adjt.get(y).add((long) x); }</b>	Beolvassa az éleket (x -> y). Hozzáadja x -> y élt az eredeti gráfhoz (adj), és y -> x élt a fordított gráfhoz (adjt).
<b>long[] finish = new long[n + 1]; Arrays.fill(finish, -1); int[] vis = new int[n + 1]; long[] timer = new long[1];</b>	Inicializálja az első DFS-hez szükséges tömböket: finish (befejezési idők), vis (látogatott jelző) és timer (időmérő, egyelemű tömb a pass-by-reference szimulálásához).
<b>for (int i = 1; i <= n; i++) { if (vis[i] == 0) { dfs(i, adj, finish, timer, vis); } }</b>	FUTTATJA AZ ELSŐ DFS-t (DFS1): Végigmegy az összes csúcson, és elindítja a dfs függvényt az eredeti gráfon (adj) a befejezési idők (finish time) kiszámításához.
<b>Integer[] ord = new Integer[n]; for (int i = 0; i < n; i++) { ord[i] = i + 1; }</b>	Létrehoz egy segédtömböt (ord) a csúcsok 1-től N-ig tartó sorszámainak tárolására.
<b>Arrays.sort(ord, (a, b) -> Long.compare(finish[b], finish[a]));</b>	Rendezi a csúcsokat a befejezési idők csökkenő sorrendje alapján. Ez a Kosaraju algoritmus kulcsfontosságú lépése.
<b>Arrays.fill(vis, 0); long c = 0; long[] kingdom = new long[n + 1];</b>	Újrainicializálja a vis tömböt, beállítja a komponensszámlálót (c) 0-ra, és inicializálja a kingdom tömböt (a csúcsokhoz rendelt SCC azonosító).
<b>for (int i = 0; i < n; i++) { if (vis[ord[i]] == 0) { c++; dfs2(ord[i], vis, adjt, c, kingdom); } }	FUTTATJA A MÁSODIK DFS-t (DFS2):</b> Végigmegy a csúcsokon a rendezett sorrend (ord) alapján. Minden nem látogatott csúcsnál növeli a komponensszámlálót (c), és elindítja a dfs2 függvényt a fordított gráfon (adjt), megtalálva ezzel egy új SCC-t (királyságot).
<b>System.out.println(c);</b>	Kiírja az SCC-k (királyságok) teljes számát.
<b>StringBuilder sb = new StringBuilder(); for (int i = 1; i <= n; i++) { sb.append(kingdom[i]).append(" "); }</b>	Felépít egy stringet a csúcsokhoz rendelt SCC azonosítókkal.
<b>System.out.println(sb.toString().trim());</b>	Kiírja a csúcsok SCC-azonosítóit.

            </pre>
        </div>
    </div>
</div>

</body>
</html>
