<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Range</title>
    <style>
        :root {
            --primary-color: #2c3e50; /* Sötétkék/szürke */
            --secondary-color: #3498db; /* Élénk kék */
            --background-color: #ecf0f1; /* Világosszürke */
            --text-color: #2c3e50;
            --code-bg-color: #bdc3c7; /* Középszürke kód háttér */
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            font-style: italic;
            color: #7f8c8d;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .section p {
            margin-bottom: 10px;
        }
        .image-container {
            text-align: center;
            margin: 20px 0;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .code-container {
            background-color: var(--code-bg-color);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li::before {
            content: "• ";
            color: var(--secondary-color);
        }
        strong {
            color: var(--primary-color);
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Mountain Range</h1>
        <p>Példa input: 10 20 15 17 35 25 40 12 19 13 12</p>
    </header>

    <div class="image-container">
        <img src="MR fotó.png" alt="A fa struktúrát ábrázoló diagram">
    </div>

    <div class="section">
        <p>Ezt a programot úgy kell elképzelni, mint egy játékot, ahol van egy sor hegy, és meg kell találni a leghosszabb utat, amin végig tudunk menni úgy, hogy **mindig lefelé haladunk**.</p>
        <p>A program ezt a feladatot három fő lépésben oldja meg:</p>
    </div>

    <div class="section">
        <h2>1. Beolvasás és előkészítés</h2>
        <p>A program először beolvassa a hegyek magasságait. A felhasználónak be kell írnia n darab számot, szóközökkel elválasztva. A program ezután a beolvasott szövegből egy listát készít a magasságokból.</p>
    </div>

    <div class="section">
        <h2>2. A "szülő" hegyek megkeresése</h2>
        <p>A program sorra veszi a hegyeket, és minden hegyhez megkeresi azt a **legközelebbi, nála alacsonyabb hegyet**, ami "alatta" van az ereszkedő úton. Ezt az alacsonyabb hegyet hívjuk a **szülőnek**. Képzeld el, hogy a hegyeket egymás után rakod egy **verembe (stack)**.</p>
        <p>A verem úgy működik, mint egy tartály, amiben lentről felfelé haladva egymásra vannak helyezve a beletett tárgyak: amit utoljára raktál bele, azt veszed ki először.</p>
        <p>A program végigmegy a hegyek listáján:</p>
        <ul>
            <li>Ha a mostani hegy **magasabb**, mint a verem tetején lévő, akkor az lesz a szülője. Ezt a párosítást el is menti.</li>
            <li>Ha a mostani hegy **alacsonyabb**, mint a verem tetején lévő, akkor kiveszi azt a veremből, mert arra mehetünk tovább. Ezt addig csinálja, amíg nem talál egy nála magasabbat, vagy ki nem ürül a verem.</li>
        </ul>
        <p>Ezzel a módszerrel a program egy "családfát" épít a hegyekből, ahol minden hegynek van egy szülője, kivéve a legmagasabbakat.</p>
    </div>

    <div class="section">
        <h2>3. A leghosszabb út kiszámítása</h2>
        <p>Most, hogy megvan a családfa, már csak meg kell mérni a leghosszabb "ágat". Ezt egy különleges funkcióval csinálja a program, ami a **depth** nevet kapta. Ez a funkció megmondja, hogy egy adott hegy milyen mélyen van a családfában.</p>
        <ul>
            <li>A funkció megnézi egy hegy szülőjét, majd megkérdezi tőle, hogy ő milyen mélyen van. Ehhez hozzáad egyet, és máris megkapja a saját mélységét.</li>
            <li>Hogy ne kelljen újra és újra kiszámolnia ugyanazt, a program **megjegyzi** (ezt hívják **memoizációnak**) az eredményeket egy "emlékeztető" táblázatba.</li>
        </ul>
        <p>Végül a program végigmegy az összes hegyen, kiszámolja a "mélységüket", és kiírja a legnagyobb számot. Ez a szám lesz a leghosszabb ereszkedő ösvény hossza.</p>
    </div>

    <div class="section">
        <h2>Java kód</h2>
        <div class="code-container">
            <pre>
public class MountainGliding {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Set recursion limit is not directly applicable in Java, but we can manage stack depth.

        scanner.nextLine();
        String[] heightsInput = scanner.nextLine().split(" ");

        int[] heights = new int[heightsInput.length];

        for (int i = 0; i < heightsInput.length; i++) {
            heights[i] = Integer.parseInt(heightsInput[i]);
        }

        Map<Integer, Integer> up = new HashMap<>();
        Stack<Pair> stack = new Stack<>();
        stack.push(new Pair(Double.MAX_VALUE, null));

        for (int i = 0; i < heights.length; i++) {
            Integer kid = null;
            while (heights[i] > stack.peek().height) {
                kid = stack.pop().index;
            }
            if (heights[i] < stack.peek().height) {
                up.put(i, stack.peek().index);
                if (kid != null) {
                    up.put(kid, i);
                }
                stack.push(new Pair(heights[i], i));
            }
        }

        Map<Integer, Integer> memo = new HashMap<>();
        memo.put(null, 0);

        int maxDepth = 0;
        for (Integer key : up.keySet()) {
            maxDepth = Math.max(maxDepth, depth(key, up, memo));
        }

        System.out.println(maxDepth);
    }

    private static int depth(Integer i, Map<Integer, Integer> up, Map<Integer, Integer> memo) {
        if (!memo.containsKey(i)) {
            memo.put(i, depth(up.get(i), up, memo) + 1);
        }
        return memo.get(i);
    }

    static class Pair {
        double height;
        Integer index;

        Pair(double height, Integer index) {
            this.height = height;
            this.index = index;
        }
    }
}

        A kód részletes magyarázata
1. Beolvasás és adatok előkészítése
        
public class MountainGliding { ... }: Ez az osztály tartalmazza a teljes programkódot. A neve, "MountainGliding", a feladatra utal.
public static void main(String[] args) { ... }: A program belépési pontja, a kód futása itt kezdődik.
Scanner scanner = new Scanner(System.in);: Létrehoz egy Scanner objektumot, amivel beolvashatjuk a felhasználói bemenetet a konzolról.
scanner.nextLine();: Ez a sor beolvas egy teljes sort, de nem tárolja el. Gyakran használják, ha a bemenetben van egy üres sor, vagy a feladatleírás része.
String[] heightsInput = scanner.nextLine().split(" ");: A következő sort beolvassa, és a szóközök mentén feldarabolja, így egy szöveges tömböt kapunk (pl. ["150", "160", "145"]).
int[] heights = new int[heightsInput.length];: Létrehoz egy új, egész számokat tartalmazó tömböt
for (int i = 0; i < heightsInput.length; i++) { ... }: Ez a ciklus végigmegy a heightsInput tömb minden elemén.
heights[i] = Integer.parseInt(heightsInput[i]);: A Integer.parseInt() metódussal átalakítja a szöveges számokat valós int számokká, majd beilleszti a heights tömbbe.

2. "Szülő" hegyek megkeresése

Map<Integer, Integer> up = new HashMap<>();: Létrehoz egy térképet (Map), ami a hegyek "szülő-gyerek" kapcsolatát tárolja.
Stack<Pair> stack = new Stack<>();: Létrehoz egy vermet (Stack), ami a hegyek magasság-index párosait tárolja. A verem úgy működik, mint egy tálca a menzán: amit utoljára raktál rá, azt veszed le először.
stack.push(new Pair(Double.MAX_VALUE, null));: A verembe betesz egy speciális, virtuális "hegyet" a lehető legnagyobb magassággal, ami biztosítja, hogy a verem soha ne legyen üres.
for (int i = 0; i < heights.length; i++) { ... }: Egy ciklus, ami végigmegy az összes bemeneti hegyen.
Integer kid = null;: Segédváltozó, ami azokat a hegyeket tárolja, amiket a veremből kiveszünk.
while (heights[i] > stack.peek().height) { ... }: Ez a belső ciklus addig fut, amíg a jelenlegi hegy magasabb, mint a verem tetején lévő. Ekkor kiveszi az alacsonyabb hegyet a veremből, és elmenti az indexét a 
kid változóba.
if (heights[i] < stack.peek().height) { ... }: Ha a mostani hegy alacsonyabb, mint a verem tetején lévő, akkor az utóbbi lesz a szülője.
up.put(i, stack.peek().index);: Hozzáadja a up térképhez, hogy a jelenlegi hegy (i) "szülője" a verem tetején lévő hegy.
if (kid != null) { up.put(kid, i); }: Ha a while ciklusban kivettünk hegyeket, az utoljára kivett hegy (kid) "szülője" a mostani hegy (i) lesz.
stack.push(new Pair(heights[i], i));: A jelenlegi hegyet beteszi a verembe.

3. A leghosszabb út kiszámítása

Map<Integer, Integer> memo = new HashMap<>();: Ez egy másik térkép, ami a memoizációhoz (dinamikus programozás) szolgál. Ide menti a már kiszámolt útvonalak hosszát.
memo.put(null, 0);: A "gyökérelem" (a null indexű, virtuális hegy) mélységét 0-nak állítja be.
int maxDepth = 0;: Ez a változó tárolja a valaha talált leghosszabb út hosszát.
for (Integer key : up.keySet()) { ... }: Ez a ciklus végigmegy minden "gyerek" hegyen, ami a up térképben szerepel.
maxDepth = Math.max(maxDepth, depth(key, up, memo));: Meghívja a depth metódust minden hegyre, hogy kiszámolja az onnan induló út hosszát, és a maxDepth változóban a legnagyobb értéket tartja meg.
System.out.println(maxDepth);: Kiírja a végső eredményt a konzolra.

4. Segéd metódusok és osztályok

private static int depth(...) { ... }: Ez egy rekurzív függvény.
if (!memo.containsKey(i)) { ... }: Ha az adott hegy mélységét még nem számolta ki...
memo.put(i, depth(up.get(i), up, memo) + 1);: ...akkor rekurzívan meghívja magát a szülőre, és az eredményhez hozzáad egyet, majd elmenti a memo térképbe.
return memo.get(i);: Visszaadja a tárolt mélységértéket.
static class Pair { ... }: Ez egy egyszerű belső osztály, ami két adatot tárol: egy hegy magasságát (height) és a pozícióját (index).
            </pre>
        </div>
    </div>
</div>

</body>
</html>
