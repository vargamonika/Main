<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Range</title>
    <style>
        :root {
            --primary-color: #2c3e50; /* Sötétkék/szürke */
            --secondary-color: #3498db; /* Élénk kék */
            --background-color: #ecf0f1; /* Világosszürke */
            --text-color: #2c3e50;
            --code-bg-color: #bdc3c7; /* Középszürke kód háttér */
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            font-style: italic;
            color: #7f8c8d;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .section p {
            margin-bottom: 10px;
        }
        .image-container {
            text-align: center;
            margin: 20px 0;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .code-container {
            background-color: var(--code-bg-color);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li::before {
            content: "• ";
            color: var(--secondary-color);
        }
        strong {
            color: var(--primary-color);
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Josephus Problem II</h1>
        <p>Példa input: 10 20 15 17 35 25 40 12 19 13 12</p>
    </header>

    <div class="image-container">
        <img src="https://i.imgur.com/example_image.png" alt="A fa struktúrát ábrázoló diagram">
    </div>

    <div class="section">


<p>A Josephus Problem II egy matematikai és algoritmikus feladvány, amely egy körben álló emberek eliminációját modellezi.</p>
<p>A feladat szövege szerint:</p>
        <ul>
            <li>n gyerek van egy körben, 1-től n-ig számozva.</li>
            <li>A játék során ismételten k gyereket kihagynak, és a következő gyereket eltávolítják a körből.</li>
            <li>A feladat az, hogy milyen sorrendben távolítják el a gyerekeket.</li>
        </ul>    
<p>Mivel a gyerekek száma nagyon nagy lehet (2 * 10^5), és az eliminálás sorrendjét kell megadni, egy egyszerű lista használata túl lassú lenne. Ezért a program egy Fenwick-fa (vagy Binary Indexed Tree) nevű adatszerkezetet használ a hatékonyság érdekében. Ez az adatszerkezet lehetővé teszi, hogy a gyerekek megkeresése és eltávolítása gyors legyen.</p>

    <div class="section">
        <h2>1.  program működésének magyarázata</h2>

<p>1.	Fenwick-fa (Binary Indexed Tree): A FenwickTree osztály felelős a gyerekek hatékony nyilvántartásáért. Kezdetben minden gyerek egy-egy 1-es értéket kap a fában, ami azt jelenti, hogy "él". Ha egy gyereket eltávolítunk, az értékét 0-ra állítjuk. A fa lehetővé teszi, hogy O(log n) idő alatt kiszámítsuk, hány élő gyerek van egy adott pozícióig.</p>
<p>2.	findKth(k) metódus: Ez a legfontosabb rész. Bináris keresést használ a Fenwick-fán, hogy O(log n * log n) idő alatt megtalálja a k-adik élő gyereket. A keresés abból áll, hogy egy "gyorsítótár" segítségével megkeressük azt a pozíciót, ahol a gyerekszám megegyezik a keresett sorszámmal.</p>
<p>3.	Fő logika a main metódusban:</p>
        <ul>
            <li>Inicializálja a Fenwick-fát, és feltölti n darab 1-es értékkel.</li>
            <li>Egy for ciklus n-től 1-ig fut, minden lépésben egy gyereket eltávolítva.</li>
            <li>currentIndex = (currentIndex + k) % i;: Ez a moduláris aritmetika kiszámítja, hogy hányadik gyereket kell eltávolítani a jelenlegi körben lévő élő gyerekek között. Az i értéke a körben lévő gyerekek számát jelenti.</li>
            <li>int removedIndex = ft.findKth(currentIndex + 1);: A findKth metódus megtalálja a tényleges indexét a gyerektömbben.</li>
            <li>ft.add(removedIndex, -1);: Eltávolítja a gyereket a Fenwick-fáról, csökkentve az értékét 1-gyel.</li>
            <li>out.print(removedIndex + 1 + " ");: Kiírja a gyerek sorszámát.</li>
        </ul>
<p>Ez a megoldás a O(n * log^2 n) komplexitású, ami bőven a megadott időkorláton belül van.</p>


        
        <p>A program először beolvassa a hegyek magasságait. A felhasználónak be kell írnia a számokat, szóközökkel elválasztva. A program ezután a beolvasott szövegből egy listát készít a magasságokból.</p>
    </div>

        <h2>3. A leghosszabb út kiszámítása</h2>
        <p>Most, hogy megvan a családfa, már csak meg kell mérni a leghosszabb "ágat". Ezt egy különleges funkcióval csinálja a program, ami a **depth** nevet kapta. Ez a funkció megmondja, hogy egy adott hegy milyen mélyen van a családfában.</p>
        <ul>
            <li>A funkció megnézi egy hegy szülőjét, majd megkérdezi tőle, hogy ő milyen mélyen van. Ehhez hozzáad egyet, és máris megkapja a saját mélységét.</li>
            <li>Hogy ne kelljen újra és újra kiszámolnia ugyanazt, a program **megjegyzi** (ezt hívják **memoizációnak**) az eredményeket egy "emlékeztető" táblázatba.</li>
        </ul>
        <p>Végül a program végigmegy az összes hegyen, kiszámolja a "mélységüket", és kiírja a legnagyobb számot. Ez a szám lesz a leghosszabb ereszkedő ösvény hossza.</p>
    </div>

    <div class="section">
        <h2>Java</h2>
        <div class="code-container">
            <pre>
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * A Josephus Problem II megoldása egy Fenwick-fa (Binary Indexed Tree) segítségével.
 * Ez a megoldás hatékonyan kezeli a nagyméretű bemeneteket is.
 */
public class JosephusProblemII {

    static class FenwickTree {
        private int[] tree;
        private int size;

        public FenwickTree(int size) {
            this.size = size;
            this.tree = new int[size + 1];
        }

        public void add(int index, int value) {
            index++;
            while (index <= size) {
                tree[index] += value;
                index += index & (-index);
            }
        }

        public int query(int index) {
            index++;
            int sum = 0;
            while (index > 0) {
                sum += tree[index];
                index -= index & (-index);
            }
            return sum;
        }

        public int findKth(int k) {
            int low = 0;
            int high = size - 1;
            int result = -1;

            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (query(mid) >= k) {
                    result = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            return result;
        }
    }

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);

        int n = in.nextInt();
        int k = in.nextInt();

        FenwickTree ft = new FenwickTree(n);
        for (int i = 0; i < n; i++) {
            ft.add(i, 1);
        }

        int currentIndex = 0;

        for (int i = n; i > 0; i--) {
            currentIndex = (currentIndex + k) % i;

            int removedIndex = ft.findKth(currentIndex + 1);

            ft.add(removedIndex, -1);

            out.print(removedIndex + 1 + " ");
        }

        out.close();
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }

            </pre>
        </div>
    </div>
</div>

</body>
</html>
