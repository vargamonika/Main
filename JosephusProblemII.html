<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mountain Range</title>
    <style>
        :root {
            --primary-color: #2c3e50; /* Sötétkék/szürke */
            --secondary-color: #3498db; /* Élénk kék */
            --background-color: #ecf0f1; /* Világosszürke */
            --text-color: #2c3e50;
            --code-bg-color: #bdc3c7; /* Középszürke kód háttér */
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        header {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--primary-color);
            margin-bottom: 20px;
        }
        header h1 {
            color: var(--primary-color);
            font-size: 2.5em;
            margin: 0;
        }
        header p {
            font-style: italic;
            color: #7f8c8d;
        }
        .section {
            margin-bottom: 30px;
        }
        .section h2 {
            color: var(--secondary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .section p {
            margin-bottom: 10px;
        }
        .image-container {
            text-align: center;
            margin: 20px 0;
        }
        .image-container img {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .code-container {
            background-color: var(--code-bg-color);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        ul {
            list-style-type: none;
            padding: 0;
        }
        ul li::before {
            content: "• ";
            color: var(--secondary-color);
        }
        strong {
            color: var(--primary-color);
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Josephus Problem II</h1>
       
    </header>

    <div class="image-container">
        <img src="Josephus.png" alt="Josephus Problem II">
    </div>

    <div class="section">


<p>A Josephus Problem II egy matematikai és algoritmikus feladvány, amely körben álló emberek eliminációját modellezi.</p>
<p><b></b>A történet szerint Kr. u. 67-ben, a zsidó háború idején, Flavius Josephus a galileai zsidó erők egyik parancsnoka volt. Amikor a rómaiak 
    Titus vezetésével elfoglalták Jotapata erődjét, Josephus és 40 katonája elmenekült és eközben egy barlangban csapdába esett. A katonák, akik 
    szégyennek tartották volna, hogy a rómaiak fogságába essenek, öngyilkosságot akartak elkövetni. Mivel azonban a zsidó törvények tiltották az öngyilkosságot,
    a katonák megegyeztek egy közös halálos játékban (ami a Josephus probléma alapja lett): körbeállnak és minden második embert megölnek, amíg csak egy marad. A 
    túlélőnek utána meg kellett ölnie magát. Josephus kiszámolta, hogy hol kell állnia a körben ahhoz, hogy ő maradjon életben. Végül megadta magát a rómaiaknak.</b></p>
<div class="image-container">
        <img src="JP2.png" alt="JP II">
    </div> 
        <p>A feladat szövege szerint:</p>
        <ul>
            <li>n gyerek van egy körben, 1-től n-ig számozva.</li>
            <li>A játék során ismételten k gyereket kihagynak, és a következő gyereket eltávolítják a körből.</li>
            <li>A feladat az, hogy milyen sorrendben távolítják el a gyerekeket.</li>
        </ul>    
<p>Mivel a gyerekek száma, ezzel együtt a lépésszám (k) nagyon nagy lehet (akár 10^9 nagyságrendű), és az eliminálás sorrendjét kell megadni, egy egyszerű lista használata túl lassú lenne. Ezért a program egy Fenwick-fa (vagy Binary Indexed Tree) nevű adatszerkezetet használ a hatékonyság érdekében. Ez az adatszerkezet lehetővé teszi, hogy a gyerekek megkeresése és eltávolítása gyors legyen.</p>

    <div class="section">
        <h2>1.  program működésének magyarázata</h2>

<p>1.	Fenwick-fa (Binary Indexed Tree): A FenwickTree osztály felelős a gyerekek hatékony nyilvántartásáért. Kezdetben minden gyerek egy-egy 1-es értéket kap a fában, ami azt jelenti, hogy "játékban van". Ha egy gyereket eltávolítunk, az értékét 0-ra állítjuk. A fa lehetővé teszi, hogy O(log n) idő alatt kiszámítsuk, hány játékban levő gyerek van egy adott pozícióig.</p>
<div class="image-container">
        <img src="Fenwick fa 2.png" alt="BIT">
    </div>

<div class="image-container">
        <img src="BI.png" alt="Bináris indexelés">
    </div>
        
<p>2.	findKth(k) metódus: Ez a legfontosabb rész. Bináris keresést használ a Fenwick-fán, hogy O(log n * log n) idő alatt megtalálja a k-adik játékban levő gyereket. A keresés abból áll, hogy egy "gyorsítótár" segítségével megkeressük azt a pozíciót, ahol a gyerekszám megegyezik a keresett sorszámmal.</p>
<p>3.	Fő logika a main metódusban:</p>
        <ul>
            <li>Inicializálja a Fenwick-fát, és feltölti n darab 1-es értékkel.</li>
            <li>Egy for ciklus n-től 1-ig fut, minden lépésben egy gyereket eltávolítva.</li>
            <li>currentIndex = (currentIndex + k) % i;: Ez kiszámítja, hogy hányadik gyereket kell eltávolítani a jelenlegi körben lévő gyerekek között. Az i értéke a körben lévő gyerekek számát jelenti.</li>
            <li>int removedIndex = ft.findKth(currentIndex + 1);: A findKth metódus megtalálja a tényleges indexét a gyerektömbben.</li>
            <li>ft.add(removedIndex, -1);: Eltávolítja a gyereket a Fenwick-fáról, csökkentve az értékét 1-gyel.</li>
            <li>out.print(removedIndex + 1 + " ");: Kiírja a gyerek sorszámát.</li>
        </ul>
<p>Ez a megoldás a O(n * log^2 n) komplexitású, ami a megadott időkorláton belül van.</p>
    </div>

    </div>

    <div class="section">
        <h2>Java</h2>
        <div class="code-container">
            <pre>
import java.io.OutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.util.StringTokenizer;
import java.io.BufferedReader;
import java.io.InputStreamReader;

/**
 * A Josephus Problem II megoldása egy Fenwick-fa (Binary Indexed Tree) segítségével.
 * Ez a megoldás hatékonyan kezeli a nagyméretű bemeneteket is.
 */
public class JosephusProblemII {

    static class FenwickTree {
        private int[] tree; <span style="color: blue;">(A Fenwick-fa reprezentációja)
        Nem az eredeti tömb elemeit tárolja, hanem részösszegeket, ezért az adott elemhez kapcsolódó 
            előtagösszegeket is frissíteni kell.)</span style="color: blue;">
        private int size;

        public FenwickTree(int size) {
            this.size = size;
            this.tree = new int[size + 1];
        }

        public void add(int index, int value) { <span style="color: blue;">(Hozzáadja a megadott értéket a fa adott pontjához)</span style="color: blue;">
            index++;
            while (index <= size) {
                tree[index] += value;
                index += index & (-index); <span style="color: blue;">(A fában felfelé haladva számolja az elemek összegét)</span style="color: blue;">
            }
        }

        public int query(int index) {
            index++;
            int sum = 0;
            while (index > 0) {
                sum += tree[index];
                index -= index & (-index); <span style="color: blue;">(A gyökér felé haladva számolja az elemek összegét)</span style="color: blue;">
            }
            return sum;
        }

        public int findKth(int k) {  <span style="color: blue;">(Bináris kereséssel találja meg a következő k-adik elemet)</span style="color: blue;">
            int low = 0;
            int high = size - 1;
            int result = -1;

            while (low <= high) {
                int mid = low + (high - low) / 2;
                if (query(mid) >= k) {
                    result = mid;
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            }
            return result;
        }
    }

    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        InputReader in = new InputReader(inputStream);
        PrintWriter out = new PrintWriter(outputStream);

        int n = in.nextInt();
        int k = in.nextInt();

        FenwickTree ft = new FenwickTree(n);
        for (int i = 0; i < n; i++) {
            ft.add(i, 1);
        }

        int currentIndex = 0;

        for (int i = n; i > 0; i--) {
            currentIndex = (currentIndex + k) % i;
            int removedIndex = ft.findKth(currentIndex + 1);
            ft.add(removedIndex, -1);
            out.print(removedIndex + 1 + " ");
        }
        out.close();
    }

    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }


FenwickTree osztály
            
Ez az osztály a Fenwick-fa adatszerkezetet valósítja meg, amely hatékonyan tudja kezelni a gyerekek "játékban levő" és "eltávolított" állapotát. A fa a prefix összegek tárolására specializálódott.
<b>private int[] tree;</b>: Ez a tömb a Fenwick-fa belső reprezentációja.
<b>private int size;</b>: A gyerekek teljes számát tárolja.
<b>public FenwickTree(int size):</b> Ez a konstruktor inicializálja a fát a megadott mérettel.
<b>public void add(int index, int value):</b>
<b>index++;</b>: Mivel a fa 1-től indexelt, a bemeneti indexet eggyel megnöveli.
<b>while (index <= size) { ... }</b>: Ez a ciklus addig fut, amíg az index a fán belül van.
<b>tree[index] += value;</b>: Hozzáadja a megadott értéket a fa adott pontjához.
<b>index += index & (-index);</b>: Ez a legfontosabb sor. Egy bitművelet segítségével megkeresi a következő olyan indexet a fában, amit szintén frissíteni kell. A (-index) binárisan a kettes komplemensét adja vissza, és az & bitenkénti ÉS operátorral a legutolsó beállított bitet találja meg, ezzel navigálva a fában felfelé.
<b>public int query(int index):</b>
<b>index++;</b>: A Fenwick-fa indexe 1-től kezdődik, ezért a bemeneti indexet megnöveli.
<b>int sum = 0;</b>: Inicializálja az összeget.
<b>while (index > 0) { ... }</b>: Visszafelé haladva a fa gyökere felé számolja az elemek összegét.
<b>sum += tree[index];</b>: Hozzáadja az aktuális faelem értékét az összeghez.
<b>index -= index & (-index);</b>: Ismét a bitművelet, de most az ellentétes irányba navigál, hogy az összes szükséges elemet összegezze.
<b>public int findKth(int k)</b>: Ez a metódus bináris keresést használ a Fenwick-fán, hogy megtalálja a k-adik "játékban levő" gyereket.
<b>while (low <= high)</b>: A standard bináris keresési ciklus.
<b>if (query(mid) >= k)</b>: Ellenőrzi, hogy a mid indexig lévő gyerekek száma eléri-e a k-t. Ha igen, a result-ba menti az indexet, és a keresési tartományt balra szűkíti, hátha van korábbi érvényes index.
<b>else</b>: Ha nem, a keresési tartományt jobbra tolja.
    
main metódus
    
Ez a program fő belépési pontja, ami a Josephus-probléma logikáját valósítja meg.
<b>InputReader in = new InputReader(inputStream);</b>: Egy gyors beolvasó osztályt inicializál.
<b>int n = in.nextInt(); int k = in.nextInt();</b>: Beolvassa a gyerekek számát (n) és a lépésközt (k).
<b>FenwickTree ft = new FenwickTree(n);</b>: Létrehoz egy Fenwick-fát n gyerek számára.
<b>for (int i = 0; i < n; i++) { ft.add(i, 1); }</b>: Kezdetben minden gyerek "játékban van", így a fát feltölti 1-esekkel.
<b>int currentIndex = 0;</b>: Ez a változó a kör aktuális pozícióját tárolja.
<b>for (int i = n; i > 0; i--) { ... }</b>: A fő ciklus, ami minden lépésben egy gyereket eliminál. Az i változó a körben lévő, még élő gyerekek számát mutatja.
<b>currentIndex = (currentIndex + k) % i;</b>: Ez kiszámítja az eltávolítandó gyerek relatív pozícióját a jelenlegi körben.
<b>int removedIndex = ft.findKth(currentIndex + 1);</b>: A findKth metódus megkeresi a gyerek tényleges (0-tól indexelt) pozícióját a teljes n gyerekből álló sorozatban.
<b>ft.add(removedIndex, -1);</b>: A FenwickTree add metódusával jelzi, hogy a gyerek már nincs a körben.
<b>out.print(removedIndex + 1 + " ");</b>: Kiírja az eltávolított gyerek sorszámát (mivel a feladat 1-től számoz, a 0-tól indexelt eredményhez 1-et ad).
<b>out.close();</b>: Lezárja a kimeneti streamet.

InputReader osztály
Ez egy segédosztály, ami a konzolról történő gyors beolvasást teszi lehetővé, különösen nagy bemeneti adatok esetén. Puffereléssel olvassa be a sorokat, majd egy StringTokenizer segítségével darabolja a szóközök mentén, így gyorsabb, mint a standard Scanner.
            
            </pre>
        </div>
    </div>
</div>

</body>
</html>
